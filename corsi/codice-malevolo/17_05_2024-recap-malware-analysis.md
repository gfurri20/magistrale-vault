Malware: `Chapter9 > Lab09-03.exe`.

Indichiamo tutti gli step da seguire per analizzare un malware per intero:
1. pestudio
2. analisi dinamica con regshot e process monitor
3. analisi con ghidrantibus üêâ e IDA nazionale üëµ

# 1. pestudio
Troviamo una API `NetScheduleJobAdd`, tale chiamata invia un processo da eseguire in un'ora e una data futura specificata ad un server remoto.

Vediamo che vengono usate diverse chiamate legate alla gestione dell'heap.

Si nota inoltre l'uso di libreria per:
- sleep
- creazione/modifica di file
- terminazione di processi
- modifiche all'environment
- caricamento di dll esterne

Nella sezione `strings` notiamo che c'√® la `dll3` che non viene dichiarata negli imports.

# 2. regshot + process monitor
Una volta avviato il malware appare una console che mostra 3 righe di output, inoltre √® possibile notare che √® stato creato un file temporaneo nella cartella del malware.

## regshot
Vengono aggiunti due file tra cui `temp.txt`.
Vengono aggiunti anche chiavi di registri:
- `LocalMachine` -> percorso all'eseguibile del malware

## process monitor
Filtriamo per operazioni svolte:
- nome del processo
- `WriteFile`
- `RegSetValue`
- `SetDispositionInformationFile`

Attraverso tali filtri vediamo 3 eventi:
- n'altra roba dialoporcello
- creazione del file temp.txt
- modifica del valore del registro

# 3. ghidra üêâ + IDA üëµ
Aprire il file in ghidrantibus per analizzarne le viscere.

> [!info] Edit Tool Options
> - Bytes field -> 1
> - Cursor text highlight
> - altre opzione che non ho visto perch√© s√¨

Innanzitutto si cerca il `main`, quest'ultimo chiama le funzioni `dll1Print` e `dll2Print`.
Apriamo IDA per analizzare meglio gli sbrodolamenti del malware.

`DLL1Print` recupera il CurrentProcessId associato al malware e lo stampa a video.

`DLL2Print` crea il file temporaneo `temp.txt`, stampa a video il suo puntatore e infine lo restituisce al chiamante (lo piazza in `eax`, incredibol! üå†), in realt√† ci√≤ che restituisce l'handle √® `DLL3ReturnJ`.

Successivamente carica la `DLL3.dll` e successivamente carica la funzione `DLL3Print`.

`DLL3Print` stampa il puntatore alla struttura che viene creata, all'interno della struttura viene salvato:
- un comando ping in formato `WideChar`
- un numero in hex (in dec: 3'600'000)
- altri parametri difficili da capire al momento
`DLL3GetStructure` restituisce la struttura appena creata

Si nota che tale struttura viene usata da NetScheduleJobAdd, ne ricaviamo quindi le informazioni `AT_INFO`: https://learn.microsoft.com/it-it/windows/win32/api/lmat/ns-lmat-at_info"

Aggiungiamo la struttura in IDA con il tasto `ins`, per leggere meglio il codex.

Quindi il malware schedula il Job ed infine dorme per un tot. di secondi. Poi muore il coglione di merda bastardo maledetto.