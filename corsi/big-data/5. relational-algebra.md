Piccola parentesi sull'algebra relazionale e relativa implementazione tramite il paradigma MapReduce.

---

# Operatori dell'Algebra Relazionale
Molte operazioni sui dati si adattano bene al **modello dell’algebra relazionale**.
Negli **RDBMS tradizionali**, le query tendono a:
- Recuperare **piccole quantità di dati** mirati.
- Essere **selettive**, sfruttando indici e ottimizzazioni.

Il modello **MapReduce** lavora in contesti dove:
- Si effettuano **scansioni complete di enormi dataset** (full scan).
- Le query sono **poco selettive**: vengono processati tutti i dati, senza cercare solo subset ristretti.
- Serve quindi una **riprogettazione delle query** tradizionali per adattarsi a una scala “big data”.

## Selezione
$\sigma_C(R)$ - filtra le tuple che rispettano una determinata condizione $C$

**MapReduce Implementation**:
- Mapper
	- per ogni tupla $t \in R$, controlla la condizione ed in caso `True` emette $(t, \texttt{""})$
- Reducer
	- reducer che esegue l'operazione di identità

## Proiezione
$\Pi_S(R)$ - filtra per subset di attributi S tutte le tuple

**MapReduce Implementation**:
- Mapper
	- per ogni tupla $t \in R$, crea una tupla $t'$ la quale non contiene gli attributi in $S$
	- emette $(t', \texttt{1})$
- Reducer
	- per ogni $(t', \texttt{1})$, raggruppa per chiave uguale producendo $(t', \texttt{""})$
	- notare come il reducer esegue, in sostanza, un'eleminazione dei duplicati

## Unione, Intersezione e Differenza
Questo tipo di operazioni agiscono su Relazioni che possiedono lo stesso schema (stesso set di attributi).

### Unione
$F = R \cup S$ - unisce i dati di due relazioni $R$ e $S$ in $F$

**MapReduce Implementation**
- Mapper
	- per ogni tupla $t \in R \vee t \in S$, emette $(t, \texttt{1})$
- Reducer
	- eliminazione dei duplicati: per ogni $(t, \texttt{1})$, raggruppa per chiave emettendo $(t, \texttt{""})$

### Intersezione
$F = R \cap S$ - mantiene solo le tuple comuni tra le due relazioni

**MapReduce Implementation**
- Mapper
	- per ogni tupla $t \in R \vee t \in S$, emette $(t, \texttt{1})$
- Reducer
	- per ogni $(t, \texttt{1})$, emette $(t, \texttt{""})$ se e solo se la lista valori è $[\texttt{1, 1}]$
	- conserva solamente le chiavi con doppia occorrenza

### Differenza
$F = R \textbackslash S$ - restituisce le tuple di $R$ che non sono in $S$

**MapReduce Implementation**
- Mapper
	- per ogni tupla $t \in R$, emette $(t, \texttt{"R"})$
	- per ogni tupla $t \in S$, emette $(t, \texttt{"S"})$
- Reducer
	- per ogni $t$ se la sua lista valori comprende $\texttt{R}$, allora emette $(t, \texttt{""})$
	- mantiene solo le tuple che appaiono R


## Raggruppamenti e Aggregazioni
$\Upsilon_X(R)$ - raggruppa tuple rispetto ad un attributo e applica funzioni di aggregazione (e.g. somma, conta, media, ecc.)
- $X$ può essere:
	- **raggruppamento** $\rightarrow$ un'attributo (o un set di attributi) di raggruppamento
	- **aggregazione** $\rightarrow$ un'espressione $\theta(A)$, dove $\theta$ è una funzione di aggregazione ed $A$ è l'attributo, non appartenente al raggruppamento, sul quale viene eseguita l'operazione

**MapReduce Implementation**
Sia $R(A, B, C)$ una relazione alla quale applichiamo $\Upsilon_{A, \theta(B)}(R)$, con $A = \{a\}$ e $B = \{b\}$.
- Mapper
	- per ogni tupla $(a, b, c)$, emette $(a, b)$
- Reducer
	- raggruppa per $a$ e computa la funzione sulla lista di valori, emettendo $(a, x)$
	- dove $x = \theta([b_1, ..., b_n])$

In caso di semplice raggruppamento, ovviamente non verrà computata nessuna funzione.


## Join Naturale
$R \bowtie S$ - combina tuple di due relazioni diverse se condividono valori su attributi in comune.

**MapReduce Implementation**
Siano $R(A,B)$ e $S(B, C)$ due relazioni, aventi in comune l'attributo $B$, l'obiettivo è quello di costruire la relazione $F(A, B, C)$ nella quale le tuple $t$ condividono lo stesso valore per $B$.
- Mapper
	- per ogni tupla $(a,b) \in R$, emette $(b, (\texttt{"R"}, a))$
	- per ogni tupla $(b,c) \in S$, emette $(b, (\texttt{"S"}, c))$
	- sostanzialmente isola la chiave utile al join di entrambe le relazioni
- Reducer
	- per ogni chiave $b$ avente come lista valori $[(\texttt{"R"}, a), (\texttt{"S"}, c)]$, emette $(b, (a,b,c))$
	- riduce tutte le tuple aventi la stessa chiave

P.S.: In generale se le tuple aventi valore specifico $b$ in $R$ sono $n$ e in $S$ sono $m$, allora il risultato finale possiederà $nm$ tuple.

