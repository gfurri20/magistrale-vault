Introduzione ai grafi nel contesto di MapReduce ed approfondimento di due algoritmi coi grafi interessanti:
- Parallel Breadth-First Search
- Page Rank
Infine, piccola panoramica su sistemi moderni come Pregel.

---
# Grafi e MapReduce
Una grande quantità di problemi sono risolvibili attraverso l'uso di grafi, ogni algoritmo del genere comprende:
- computazioni su ogni nodo, basate sulle caratteristiche del nodo stesso, dell'arco o della struttura del grafo
- la propagazione della computazione attraversando il grafo steso

## Rappresentazione del grafo
La rappresentazione del grafo (utile anche negli algoritmi basati su MapReduce) può essere messa in pratica tramite:
- **Matrici di adiacenza**
- **Liste di adiacenza**

![[graph-algorithms-image-1 | 100%]]
### Matrici di adiacenza
Il grafo viene rappresentato tramite una matrice $n \cdot n$, dove $n$ è il numero di nodi $|V|$.
Vantaggi:
- adatta a manipolazioni matematiche
- le iterazioni su righe e colonne corrispondono a computazioni su link in entrata e link in uscita
Svantaggi:
- tanto spazio sprecato
### Liste di adiacenza
Rappresentazione tramite liste in cui tutti gli zeri delle matrici di adiacenza sono eliminati.
Vantaggi:
- rappresentazione più compatta
- facile da computare sui link in uscita
Svantaggi:
- più difficile da computare sui link in **entrata**



---
# Parallel Breadth-First Search

> [!warning] Problema - Single-Source Shortest Path (SSSP)
> Trovare il percorso più corto dalla sorgente rispetto a tutti i nodi del grafo.

Sulla singola macchina tale problema è risolto grazie al famosissimo algoritmo di Dijkstra.

![Dijkstra_Animation.gif (283×222) | 500](https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif)

La **Parallel Breadth-First Search (BFS)** con **MapReduce** è una strategia fondamentale per trovare il **Single-Source Shortest Path (SSSP)** in grandi grafi distribuiti.

## Obiettivo
Obiettivi della Parallel BFS:
- trovare il cammino più breve da un nodo sorgente a tutti gli altri nodi di un grafo **distribuito** (il fine non cambia).
- utilizzare l'approccio di **flooding iterativo**, simile a una BFS classica, ma adattata a un ambiente distribuito come MapReduce.

Il **flooding iterativo** è una tecnica che imita il comportamento di un’onda che si espande progressivamente nel grafo, livello dopo livello, **a partire da un nodo sorgente**:
- ogni iterazione esplora i nodi vicini a quelli scoperti nella fase precedente
- in ogni ciclo, si scoprono i nodi a distanza crescente
- l'esecuzione si ripete finché non ci sono più nodi da scoprire

## MapReduce Implementation
Ogni nodo è rappresentato attraverso la seguente tupla:
$$\texttt{(node\_id, adjacency\_list, distance)}$$
e il grafo viene mantenuto in memoria attraverso una lista di adiacenza.

Esecuzione di una singola iterazione:
1. **Mapper**
	- per ogni nodo $n$ attivo (non ancora scoperto, quindi con distanza definita $\neq \infty$), viene emessa:
		- la propria struttura dati `emit (node_id, adjacency_list, distance)`
		- una coppia `emit (neighbor_id, adjacency_list, distanza_attuale + 1)`
2. **Shuffle & Sort**
	- raggruppa tutte le informazioni ricevute dai mapper per ciascun nodo
3. **Reducer**
	- per ogni nodo $n$
		- confronta le distanze ricevute e seleziona la minima
		- aggiorna la distanza se quella nuova è la più breve
		- emette la nuova struttura del nodo aggiornata

Ogni Job MapReduce corrisponde a un livello della BFS: ogni iterazione espande la frontiera di ricerca di un livello di nodi.
Quindi si itera finché ogni nodo non è scoperto, ovvero possiede una distanza $\neq \infty$.

Per identificare la terminazione dell'algoritmo (ogni nodo è stato scoperto) si utilizza un programma "driver" che permette la verifica, tale programma è necessario finché si uso di un paradigma iterativo.

Vantaggi:
- **adatto a grafi small-world**, ovvero di piccolo diametro e poche iterazioni
- si può **estendere facilmente** a grafi ponderati (ogni arco ha un peso) oppure ricavare direttamente il percorso più breve
Svantaggi:
- **il passaggio del grafo intero dal mapper al reducer** potrebbe essere un'operazione davvero costosa e direttamente proporzionale alla grandezza del grafo stesso



---
# Page Rank





---
# Pregel
