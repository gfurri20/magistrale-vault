Supponiamo di avere un grafo:

```mermaid
flowchart LR
	E --- A
	A --- B
	A --- C
	E --- C
	B --- D
	C --- D
	C --- B
```
Ed un nodo di partenza che in questo caso è `A`. Tale nodo è di grado 3: ad esso sono collegati 3 archi.

Scegliamo un arco dei tre ed andiamo su `B`, su cui non sono mai stato (come a Napoli, tanto meno in moto):

```mermaid
flowchart LR
	E --- A
	A --1--> B
	A --- C
	E --- C
	B --- D
	C --- D
	C --- B
```
Segnaliamo `B` come visitato e andiamo su `C`.

```mermaid
flowchart LR
	E --- A
	A --1--> B
	A --- C
	E --- C
	B --- D
	C --- D
	B --2--> C
```
Ovviamente, ogni nodo già visitato non può essere ri-visitato perché il nostro algoritmo deve essere finito.

Da `C` posso o andare in `D` oppure andare in `E`:

```mermaid
flowchart LR
	E --- A
	A --1--> B
	A --- C
	E --- C
	B --- D
	C --3,4--> D
	B --2--> C
```
Rimane utile tenere traccia, per ogni nodo, del predecessore:
$$\texttt{[None->A, B->A, B->C, C->D]}$$
`D` non può proseguire, perché tutti i nodi attorno a lui sono stati già visitati.
Però, in ordine contrario di visita, possiamo andare da `C` ad `E`:

```mermaid
flowchart LR
	E --- A
	A --1--> B
	A --- C
	C --5--> E
	B --- D
	C --3,4--> D
	B --2--> C
```
Da `E` non posso più visitare nodi nuovi. Ora, tutti i nodi si chiuderanno perché non esistono più nodi adiacenti, indico dopo la virgola l'istante in cui si chiudono i nodi.

Possiamo creare il seguente spanning tree DFS:
```mermaid
flowchart TD
	A-0,9 --- B-1,8
	B-1,8 --- C-2,7
	C-2,7 --- D-3,4
	C-2,7 --- E-5,6
```
Ogni nodo ha un tempo di vita, ovvero un $\Delta$ per il quale il nodo è "attivo". Li indico sull'albero.

